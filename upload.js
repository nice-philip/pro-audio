const express = require('express');
const multer = require('multer');
const { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } = require('@aws-sdk/client-s3');
const { v4: uuidv4 } = require('uuid');
const Album = require('./models/Album');
const path = require('path');
const fs = require('fs');
const sharp = require('sharp');
const crypto = require('crypto');

const router = express.Router();

// ‚úÖ S3 ÏÑ§Ï†ï
const s3Client = new S3Client({
    region: process.env.AWS_REGION,
    credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    }
});

// ‚úÖ Multer Î©îÎ™®Î¶¨ Ï†ÄÏû•ÏÜå ÏÑ§Ï†ï
const storage = multer.memoryStorage();

const upload = multer({
    storage: storage,
    limits: {
        fileSize: 2 * 1024 * 1024 * 1024, // 2GB
        files: 51 // Ïï®Î≤î Ïª§Î≤Ñ(1) + Ïò§ÎîîÏò§ ÌååÏùº(ÏµúÎåÄ 50)
    }
}).fields([
    { name: 'image', maxCount: 1 },
    { name: 'audio_0', maxCount: 1 },
    { name: 'audio_1', maxCount: 1 },
    { name: 'audio_2', maxCount: 1 },
    { name: 'audio_3', maxCount: 1 },
    { name: 'audio_4', maxCount: 1 },
    { name: 'audio_5', maxCount: 1 },
    { name: 'audio_6', maxCount: 1 },
    { name: 'audio_7', maxCount: 1 },
    { name: 'audio_8', maxCount: 1 },
    { name: 'audio_9', maxCount: 1 }
]);

// ‚úÖ Ïù¥ÎØ∏ÏßÄ Í≤ÄÏ¶ù Ìï®Ïàò
async function validateImage(buffer) {
    try {
        const metadata = await sharp(buffer).metadata();
        if (metadata.width !== 3000 || metadata.height !== 3000) {
            throw new Error('„Ç¢„É´„Éê„É†„Ç´„Éê„Éº„ÅØ3000x3000„Éî„ÇØ„Çª„É´„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
        }
        if (buffer.length > 10 * 1024 * 1024) {
            throw new Error('„Ç¢„É´„Éê„É†„Ç´„Éê„Éº„ÅØ10MB‰ª•‰∏ã„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
        }
        return true;
    } catch (error) {
        throw error;
    }
}

// ‚úÖ S3 ÏóÖÎ°úÎìú Ìï®Ïàò
async function uploadToS3(file, folder) {
    const filename = `${uuidv4()}_${file.originalname}`;
    const uploadParams = {
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: `${folder}/${filename}`,
        Body: file.buffer,
        ContentType: file.mimetype
    };

    try {
        await s3Client.send(new PutObjectCommand(uploadParams));
        return `https://${process.env.AWS_BUCKET_NAME}.s3.${process.env.AWS_REGION}.amazonaws.com/${folder}/${filename}`;
    } catch (error) {
        console.error(`‚ùå S3 upload failed for ${filename}:`, error);
        throw error;
    }
}

// ÏóêÎü¨ ÏùëÎãµ Ìó¨Ìçº Ìï®Ïàò
const sendErrorResponse = (res, status, message, error = null) => {
    const response = {
        success: false,
        message: message
    };

    if (error) {
        console.error('Error details:', error);
        if (process.env.NODE_ENV === 'development') {
            response.error = error.message;
            response.stack = error.stack;
        }
    }

    return res.status(status).json(response);
};

// ‚úÖ Ïï®Î≤î ÏóÖÎ°úÎìú Ï≤òÎ¶¨ ÎùºÏö∞ÌÑ∞
router.post('/', (req, res) => {
    console.log('üìù Upload request received');
    console.log('Content-Type:', req.headers['content-type']);
    console.log('Request body keys:', Object.keys(req.body || {}));
    
    upload(req, res, async (err) => {
        try {
            // Multer ÏóêÎü¨ Ï≤òÎ¶¨
            if (err instanceof multer.MulterError) {
                console.error('‚ùå Multer error:', {
                    code: err.code,
                    field: err.field,
                    message: err.message,
                    stack: err.stack
                });
                return sendErrorResponse(res, 400, `File upload error: ${err.message}`, err);
            } else if (err) {
                console.error('‚ùå Unknown upload error:', {
                    message: err.message,
                    stack: err.stack,
                    details: err
                });
                return sendErrorResponse(res, 500, `Unknown upload error: ${err.message}`, err);
            }

            console.log('üìÅ Files received:', {
                fileCount: req.files ? Object.keys(req.files).length : 0,
                fileFields: req.files ? Object.keys(req.files) : [],
                imagePresent: req.files && req.files.image ? 'yes' : 'no',
                audioFilesCount: req.files ? Object.keys(req.files).filter(key => key.startsWith('audio_')).length : 0
            });
            console.log('üìÑ Body received:', {
                bodyKeys: Object.keys(req.body || {}),
                songsPresent: req.body.songs ? 'yes' : 'no',
                songCount: req.body.songs ? req.body.songs.length : 0
            });

            // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
            if (!req.files) {
                console.error('‚ùå No files uploaded');
                return sendErrorResponse(res, 400, 'No files were uploaded');
            }

            // Ïï®Î≤î Ïª§Î≤Ñ Í≤ÄÏ¶ù
            if (!req.files.image || !req.files.image[0]) {
                console.error('‚ùå Album cover missing');
                return sendErrorResponse(res, 400, 'Album cover is required');
            }

            // Ïò§ÎîîÏò§ ÌååÏùº Í≤ÄÏ¶ù
            let audioFiles = [];
            for (let i = 0; i < 10; i++) {
                const key = `audio_${i}`;
                if (req.files[key] && req.files[key][0]) {
                    audioFiles.push(req.files[key][0]);
                }
            }

            if (audioFiles.length === 0) {
                console.error('‚ùå No audio files uploaded');
                return sendErrorResponse(res, 400, 'At least one audio file is required');
            }

            console.log('üéµ Audio files found:', audioFiles.length);

            // songs Î∞∞Ïó¥ ÌååÏã±
            let songs;
            try {
                songs = req.body.songs.map(songStr => {
                    try {
                        return JSON.parse(songStr);
                    } catch (parseError) {
                        console.error('‚ùå Song parsing error:', {
                            songString: songStr,
                            error: parseError.message
                        });
                        throw parseError;
                    }
                });
                console.log('üìù Songs parsed successfully:', songs.length);
            } catch (error) {
                console.error('‚ùå Songs parsing failed:', {
                    error: error.message,
                    songsData: req.body.songs
                });
                return sendErrorResponse(res, 400, 'Invalid songs data format', error);
            }

            // Ïï®Î≤î Ïª§Î≤Ñ S3 ÏóÖÎ°úÎìú
            try {
                const coverKey = `covers/${Date.now()}-${crypto.randomBytes(8).toString('hex')}${path.extname(req.files.image[0].originalname)}`;
                await s3Client.send(new PutObjectCommand({
                    Bucket: process.env.AWS_BUCKET_NAME,
                    Key: coverKey,
                    Body: req.files.image[0].buffer,
                    ContentType: req.files.image[0].mimetype
                }));
                console.log('‚úÖ Album cover uploaded to S3:', coverKey);
            } catch (error) {
                console.error('‚ùå Album cover S3 upload failed:', {
                    error: error.message,
                    stack: error.stack,
                    details: error
                });
                throw error;
            }

            // Ïò§ÎîîÏò§ ÌååÏùº S3 ÏóÖÎ°úÎìú
            try {
                const uploadedSongs = await Promise.all(songs.map(async (song, index) => {
                    const audioFile = audioFiles[index];
                    if (!audioFile) {
                        throw new Error(`Missing audio file for song ${index + 1}`);
                    }

                    const audioKey = `audio/${Date.now()}-${crypto.randomBytes(8).toString('hex')}${path.extname(audioFile.originalname)}`;
                    await s3Client.send(new PutObjectCommand({
                        Bucket: process.env.AWS_BUCKET_NAME,
                        Key: audioKey,
                        Body: audioFile.buffer,
                        ContentType: audioFile.mimetype
                    }));
                    console.log(`‚úÖ Audio file ${index + 1} uploaded to S3:`, audioKey);

                    return {
                        ...song,
                        audioUrl: `https://${process.env.AWS_BUCKET_NAME}.s3.${process.env.AWS_REGION}.amazonaws.com/${audioKey}`
                    };
                }));
                console.log('‚úÖ All audio files uploaded successfully');
            } catch (error) {
                console.error('‚ùå Audio files S3 upload failed:', {
                    error: error.message,
                    stack: error.stack,
                    details: error
                });
                throw error;
            }

            // Ïï®Î≤î Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            const albumData = {
                releaseDate: req.body.releaseDate,
                email: req.body.email,
                password: req.body.password,
                albumNameDomestic: req.body.albumNameDomestic,
                albumNameInternational: req.body.albumNameInternational,
                artistNameKana: req.body.artistNameKana,
                artistNameEnglish: req.body.artistNameEnglish,
                versionInfo: req.body.versionInfo,
                songs: uploadedSongs,
                albumCover: `https://${process.env.AWS_BUCKET_NAME}.s3.${process.env.AWS_REGION}.amazonaws.com/${coverKey}`,
                platforms: JSON.parse(req.body.platforms || '[]'),
                excludedCountries: JSON.parse(req.body.excludedCountries || '[]'),
                genre: req.body.genre,
                youtubeMonetize: req.body.youtubeMonetize || 'no',
                youtubeAgree: req.body.youtubeAgree === 'true',
                rightsAgreement: req.body.rightsAgreement === 'true',
                reReleaseAgreement: req.body.reReleaseAgreement === 'true',
                platformAgreement: req.body.platformAgreement === 'true',
                paymentStatus: 'completed'
            };

            console.log('Album data to save:', albumData);

            // MongoDBÏóê Ïï®Î≤î Ï†ÄÏû•
            const album = new Album(albumData);
            await album.save();

            console.log('Album saved successfully:', album._id);

            // ÏÑ±Í≥µ ÏùëÎãµ
            res.status(200).json({
                success: true,
                message: '„Ç¢„É´„Éê„É†„ÅåÊ≠£Â∏∏„Å´ÁôªÈå≤„Åï„Çå„Åæ„Åó„Åü',
                albumId: album._id
            });

        } catch (error) {
            console.error('‚ùå Upload process error:', {
                message: error.message,
                stack: error.stack,
                type: error.constructor.name,
                details: error
            });
            
            if (error.name === 'ValidationError') {
                console.error('‚ùå Validation error details:', {
                    errors: Object.keys(error.errors).map(key => ({
                        field: key,
                        message: error.errors[key].message,
                        value: error.errors[key].value
                    }))
                });
                return sendErrorResponse(res, 400, 'Validation error', error);
            }
            
            if (error.code === 11000) {
                console.error('‚ùå Duplicate key error:', {
                    keyPattern: error.keyPattern,
                    keyValue: error.keyValue
                });
                return sendErrorResponse(res, 400, 'Duplicate data error', error);
            }
            
            sendErrorResponse(res, 500, 'Upload failed', error);
        }
    });
});

// ‚úÖ Ïï®Î≤î ÏÇ≠Ï†ú ÎùºÏö∞ÌÑ∞
router.delete('/:id', async (req, res) => {
    try {
        const album = await Album.findById(req.params.id);
        if (!album) {
            return res.status(404).json({ message: '„Ç¢„É´„Éê„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì' });
        }

        // S3ÏóêÏÑú Ïï®Î≤î Ïª§Î≤Ñ ÏÇ≠Ï†ú
        if (album.albumCover) {
            const coverKey = album.albumCover.split('/').pop();
            await s3Client.send(new DeleteObjectCommand({
                Bucket: process.env.AWS_BUCKET_NAME,
                Key: `covers/${coverKey}`
            }));
        }

        // S3ÏóêÏÑú Î™®Îì† Í≥° ÌååÏùº ÏÇ≠Ï†ú
        for (const song of album.songs) {
            if (song.audioUrl) {
                const audioKey = song.audioUrl.split('/').pop();
                await s3Client.send(new DeleteObjectCommand({
                    Bucket: process.env.AWS_BUCKET_NAME,
                    Key: `audio/${audioKey}`
                }));
            }
        }

        await Album.findByIdAndDelete(req.params.id);
        res.status(200).json({ message: '„Ç¢„É´„Éê„É†„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü' });
    } catch (error) {
        console.error('‚ùå Delete process error:', error);
        res.status(500).json({
            message: '„Ç¢„É´„Éê„É†„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
            error: error.message
        });
    }
});

module.exports = router;